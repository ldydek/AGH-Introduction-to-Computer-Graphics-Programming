<!DOCTYPE html>
<!-- It's the HTML5 standard. -->

<html>

<head>
    <title>Example 01 - triangle and square</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

    <!-- The following meta line optimizes the site for mobile devices. 
		 It sets the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <style type="text/css">
        body {
            /* Set the background color of the HTML page to black */
            background-color: #000000;

            /* Hide oversized content. This prevents the scroll bars. */
            overflow: hidden;
        }
    </style>
    <!-- Include Three.js library -->
    <script src="three.js"></script>
</head>

<body>
    <!-- This is the DIV element which will contain the WebGL canvas. To be identifiable later on, the id 'WebGLCanvas' is applied to it. -->
    <div id="WebGLCanvas"> </div>

    <!-- This JavaScript block encloses the Three.js commands -->
    <script>
        // Global scene object
        var scene;

        // Global camera object
        var camera;

        var car;
        var tree;
        var forward = true;

        // Initialize the scene
        initializeScene();

        // Render the scene (map the 3D world to the 2D scene)
        renderScene();

        animateScene();

        /**
         * Initialize the scene.
         */
        function initializeScene() {

            renderer = new THREE.WebGLRenderer({ antialias: true });

            // Set the background color of the renderer to black, with full opacity
            renderer.setClearColor(0x000000, 1);

            // Get the size of the inner window (content area) to create a full size renderer
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;

            // Set the renderers size to the content areas size
            renderer.setSize(canvasWidth, canvasHeight);

            // Get the DIV element from the HTML document by its ID and append the renderers DOM
            // object to it
            document.getElementById("WebGLCanvas").appendChild(renderer.domElement);

            // Create the scene, in which all objects are stored (e. g. camera, lights,
            // geometries, ...)
            scene = new THREE.Scene();

            // Define camera and add it to the scene.
            camera = new THREE.PerspectiveCamera(90, canvasWidth / canvasHeight, 1, 100);
            camera.position.set(0, 0, 10);
            camera.lookAt(scene.position);
            scene.add(camera);

            // Create the triangle (or any arbitrary geometry).
            var triangleGeometry = new THREE.Geometry();
            triangleGeometry.vertices.push(new THREE.Vector3(0.0, 1.0, 0.0));
            triangleGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0));
            triangleGeometry.vertices.push(new THREE.Vector3(1.0, -1.0, 0.0));
            triangleGeometry.faces.push(new THREE.Face3(0, 1, 2));

            var coneGeometry = new THREE.ConeGeometry(1, 2, 8, 2);
            var boxGeometry = new THREE.BoxGeometry(1.5, 3, 1.5);


            // To color the surface, a material has to be created.
            // We use MeshBasicMaterial				 
            // from which we need in this example only 'color'.

            // Create a white basic material and activate the 'doubleSided' attribute to force the
            // rendering of both sides of each face (front and back). This prevents the so called
            // 'backface culling'. Usually, only the side is rendered, whose normal vector points
            // towards the camera. The other side is not rendered (backface culling). But this
            // performance optimization sometimes leads to wholes in the surface. When this happens
            // in your surface, simply set 'doubleSided' to 'true'.
            var leavesMaterial = new THREE.MeshBasicMaterial({
                color: 0x008000,
                side: THREE.DoubleSide
            });

            var roofMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide
            });

            // Create a mesh and insert the geometry and the material. Translate the whole mesh
            // by -1.5 on the x axis and by 4 on the z axis. Finally add the mesh to the scene.
            var leavesMesh1 = new THREE.Mesh(coneGeometry, leavesMaterial);
            var leavesMesh2 = new THREE.Mesh(coneGeometry, leavesMaterial);
            var leavesMesh3 = new THREE.Mesh(coneGeometry, leavesMaterial);

            var roofMesh = new THREE.Mesh(triangleGeometry, roofMaterial);

            // The creation of the square is done in the same way as the triangle.
            // 1. Instantiate the geometry object
            // 2. Add the vertices
            // 3. Define the faces by setting the vertices indices
            var squareGeometry = new THREE.Geometry();
            squareGeometry.vertices.push(new THREE.Vector3(-1.0, 1.0, 0.0));
            squareGeometry.vertices.push(new THREE.Vector3(1.0, 1.0, 0.0));
            squareGeometry.vertices.push(new THREE.Vector3(1.0, -1.0, 0.0));
            squareGeometry.vertices.push(new THREE.Vector3(-1.0, -1.0, 0.0));
            //squareGeometry.faces.push(new THREE.Face4(0, 1, 2, 3));         //No more Face4 in Three.js
            squareGeometry.faces.push(new THREE.Face3(0, 1, 2));
            squareGeometry.faces.push(new THREE.Face3(0, 2, 3));

            // Create a white basic material and activate the 'Doubleside' attribute 
            // (alternatives are: 'FrontSide' and 'BackSide')
            var squareMaterial = new THREE.MeshBasicMaterial({
                color: 0x8B4513,
                side: THREE.DoubleSide
            });

            var doorMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide
            });

            // Create a mesh and insert the geometry and the material. Translate the whole mesh
            // by 1.5 on the x axis and by 4 on the z axis and add the mesh to the scene.
            var wallMesh = new THREE.Mesh(squareGeometry, squareMaterial);
            var trunkMesh = new THREE.Mesh(boxGeometry, squareMaterial);
            var doorMesh = new THREE.Mesh(squareGeometry, doorMaterial);

            // creating tree and adding elements to scene below

            tree = [
                leavesMesh1,
                leavesMesh2,
                leavesMesh3,
                trunkMesh
            ]

            let treeElementsSpace = 0;

            for (var item of tree) {
                scene.add(item);
                if (item == trunkMesh) {
                    trunkMesh.scale.set(0.25, 0.5, 0);
                    trunkMesh.position.set(-5, -2.7, 0);
                    continue;
                }
                item.position.set(-5, 1.2 - treeElementsSpace, 0);
                treeElementsSpace += 1.2;
            }

            // creating house and adding elements to scene below

            const house = [
                wallMesh,
                doorMesh,
                roofMesh,
            ]

            wallMesh.position.set(1.5, -1, 5.0);
            doorMesh.position.set(1.5, -1.7, 5.0);
            doorMesh.scale.set(0.2, 0.3, 1);
            roofMesh.position.set(3, 2, 0);
            roofMesh.scale.set(2.5, 2, 1);

            for (var item of house) {
                scene.add(item);
            }

            // creating car and adding elements to scene below

            var circleGeometry = new THREE.CircleGeometry(0.5, 32);

            var carSideMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                side: THREE.DoubleSide
            });

            var carWheelMaterial = new THREE.MeshBasicMaterial({
                color: 0x808080,
                side: THREE.DoubleSide
            });

            var firstWheel = new THREE.Mesh(circleGeometry, carWheelMaterial);
            var secondWheel = new THREE.Mesh(circleGeometry, carWheelMaterial);
            var carSide = new THREE.Mesh(squareGeometry, carSideMaterial);

            car = [firstWheel, secondWheel, carSide];
            let spaceBetweenWheels = 0;

            for (let item of car) {
                scene.add(item);
                if (item == carSide) {
                    carSide.scale.set(2, 0.2, 1);
                    carSide.position.set(2.9, -5.3, 1);
                    continue;
                }
                item.position.set(2 + spaceBetweenWheels, -6, 1);
                spaceBetweenWheels += 2;
            }
        }

        /**
         * Render the scene. Map the 3D world to the 2D screen.
         */
        function renderScene() {
            renderer.render(scene, camera);
        }

        function animateScene() {
            let carVelocity = 0.04;
            for (let index in car) {
                car[index].position.x -= carVelocity;
                if (forward) {
                    car[0].position.x -= carVelocity;
                    car[1].position.x -= carVelocity;
                    car[2].position.x -= carVelocity;
                    if (car[0].position.x < -10) {
                        forward = false;
                    }
                } else {
                    car[0].position.x += carVelocity;
                    car[1].position.x += carVelocity;
                    car[2].position.x += carVelocity;
                    if (car[0].position.x > 10) {
                        forward = true;
                    }
                }
            }

            for (let index in tree) {
                if (index % 2 == 0) {
                    tree[index].rotation.y -= 0.05;
                } else {
                    tree[index].rotation.y -= 0.1;
                }
            }

            requestAnimationFrame(animateScene);
            renderScene();
        }

        // geometry -> meshBasicMaterial -> mesh
    </script>
</body>

</html>